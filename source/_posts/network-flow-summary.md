---
title: 网络流学习总结
date: 2025-03-12 10:41:00
excerpt: 网络流学习总结。。
categories: 
	- 总结
tags:
    - 网络流
    - 最大流
    - 最小割
    - 费用流
---
暂未完成。
# 定义与性质
形象地说，网络流可以看作一个输水网络，每个管道有一个单位时间内的流量限制，求最大流就是求单位时间最多可以输多少水。下面给出一些严谨的定义。
### 网络流图
带权的有向图 $G=(V,E)$，满足以下条件，则称为网络流图（容量网络）：
- 仅有一个入度为 $0$ 的顶点 $s$，称 $s$ 为源点。
- 仅有一个出度为 $0$ 的顶点 $t$，称 $t$ 为汇点。
- 每条边的权值都为非负数，称为该边的容量，记作 $c(i,j)$。

### 弧与弧的流量
弧是网络流图中的一条带权边 $(u,v)∈E$。

通过容量网络 $G$ 中每条弧 $(u,v)$ 上的实际流量记为 $f(u,v)$。

### 剩余容量与残量网络
边的剩余容量简称为残量 $c_f(u,v)=c(u,v)-f(u,v)$。

由所有边均为其残量的 $G_f(V,E_{f})$ 称为残量网络。

### 可行流与最大流
在容量网络中满足以下条件的网络流称为可行流：
- 容量限制：$ f(u, v)\le c(u,v)$，一条边的流不能超过它的容量。
- 流守恒：除非 $u = s$ 或 $u = t$，否则 $\sum_{w \in V} f(u, w) = 0$，除源点与汇点外，结点流入流量等于流出流量。

对于一个网络流图，它最大的可行流即为它的最大流。

### 增广路
增广路是一条路径 $(u_1,u_2,\cdots ,u_k)$，满足 $u_1=s,u_k=t$ 及 $c_f(u_i,u_{i+1})>0$。这表示沿这条路径传送更多流是可能的。

当且仅当剩余网络 $G_f$ 没有增广路时处于最大流。

### 性质
在任意时刻，$G$ 的网络流都满足如下性质：
- 容量限制：$ f(u, v)\le c(u,v)$，一条边的流不能超过它的容量。
- 斜对称：$ f(u,v) = -f(v,u)$，由 $u$ 到 $v$ 的净流必须是由 $v$ 到 $u$ 的净流的相反。
- 流守恒：除非 $u = s$ 或 $u = t$，否则 $\sum_{w \in V} f(u, w) = 0$，除源点与汇点外，结点流入流量等于流出流量。

# 最大流
最大流上面已有定义，即从 $s$ 到 $t$ 的最大可行流。比如对于下面的容量网络，它的最大流为 $23$。约定 $a/b$ 表示这条边的流量为 $a$，容量为 $b$。

![](/img/network-flow-summary/p1.png)

## 最大流常用算法
下面给出最大流的几种求法。
### EK算法
求最大流的最直观想法就是不断地在容量网络里找增广路，并将它跑满加入答案。但这样有一个问题：如果不巧找到了一个增广路把本来不该在最大流里的边给增广了，怎么办？

举一个很简单的例子。

![](/img/network-flow-summary/p2.png)

很容易看出它的最大流为 $4$，但我们找到一条容量为 $3$ 的增广路后就无法继续增广了。

这时我们有一种方法，即对每条边建立一条反向边，允许将流经这条边的流量撤销回去。根据斜对称的性质 $f(u,v)=-f(v,u)$，在反向边上增加一单位的流量就相当于在正向边上减少一单位流量。所以当我们增广到反向边时，也就相当于在正向边上“撤回”了这部分流量，这样就可以求出最大流。

```cpp
struct Edge{int to,nxt,f;}e[N];//f表示容量
void add(int u,int v,int c){
    e[++tot]={v,head[u],c};head[u]=tot;
    e[++tot]={u,head[v],0};head[v]=tot;
}
```

形象化地说，仍然将网络上的边看作水管，在反向边上增加流量就相当于把流出的水退回去，最终从管道中流出的水就是正向边流量减去反向边流量。

EK算法就是一种 $O(VE^2)$ 求最大流的算法。它每次选择一条最短的增广路来增广并将它跑满。修改时，将正向边的剩余容量减去新加入的流量，反向边的剩余容量加上新的流量。不断重复这个过程。可参考代码：
```cpp
int pre[N],incf[N],vis[N];
bool bfs(){
    memset(vis,0,sizeof(vis));
    queue<int> q;q.push(S);
    incf[S]=INF;vis[S]=1;
    while(q.size()) {
        //遍历残量网络，寻找是否有增广路
        int u=q.front();q.pop();
        for(int i=head[u];i;i=e[i].nxt){
            int v=e[i].to;
            if(e[i].f&&!vis[v]){
                pre[v]=i;
                incf[v]=min(incf[u],e[i].f);
                vis[v]=1;
                q.push(v);
            }
        }
    }
    return vis[T];
}
int EK(){
    int r=0;
    while(spfa()){
        r+=incf[T];
        //更新答案
        for(int i=T;i!=S;i=e[pre[i]^1].to){
            e[pre[i]].f-=incf[T];
            e[pre[i]^1].f+=incf[T];
        }
    }
    return r;
}
```
我们发现这个算法有很大的局限性，即每次遍历残量网络只能找到一条增广路，所以它效率很低。针对这一点，我们有 $O(V^2E)$ 的 Dinic 算法来优化。

### Dinic算法
我们还是按照 EK 算法的方式，每次选择最短的增广路来增广。

引入一个概念：分层图，以从 $s$ 到网络上点的最短路长度进行分组，每组就是一层。比如与原点距离为 $1$ 的点位于第一层等等。我们第一步还是 bfs 一遍残量网络，将其分好层。以一开始的网络为例：

![](/img/network-flow-summary/p3.png)

这样分好了层。因为反向边与同一层内的边不会出现在增广路上，我们先忽略他们。

![](/img/network-flow-summary/p4.png)

这样，所有边都在一条残量网络的最短路上，我们可以直接 dfs 一遍同时找到多条增广路。不断重复以上算法直到 $s$ 与 $t$ 不连通，我们就找到了最大流。这样，算法的效率就提高了很多。

我们还要在算法中加入两个优化，具体可以看代码。
```cpp
int dep[N],cur[N];//dep 深度 cur 当前弧优化
bool bfs(){//bfs残留网络，判有无增广路
	queue<int> q;
	memset(dep,-1,sizeof(dep));//未分层，设为-1
	q.push(s);dep[s]=0;//起点为0层
	cur[s]=head[s];//当前弧优化
	//从同一个点发出多条边，
	//每次按顺序dfs将某条边塞满，后续就不用找塞满的边了
	//cur记录第一条没被塞满的边，此时全没被搜过所以是head
	while(q.size()){
		int u=q.front();q.pop();
		for(int i=head[u];i;i=e[i].nxt){
			int v=e[i].to;
			if(dep[v]==-1&&e[i].f){
				//没被搜过（深度没更新）并且剩余容量大于0才有可能往这里走
				dep[v]=dep[u]+1;
				cur[v]=head[v];//当前弧优化，同上
				if(v==t) return 1;
				//找到汇点，说明存在增广路
				q.push(v);
			}
		}
	}
	return 0;
}
int find(int u,int limit){//返回增广路流量
	//当前走到u，源点到u最大流量为limit
	if(u==t) return limit;
	int flow=0;//当前点到后面流量之和
	for(int i=cur[u];i&&flow<limit;i=e[i].nxt){
		//当前弧优化：从没塞满的边开始搜
		//剪枝优化：从源点到u最多流limit，后面流超过limit也无意义
		cur[u]=i;//前面都塞满了，更新cur
		int v=e[i].to;
		if(dep[v]==dep[u]+1&&e[i].f){
			//在下一层并且这条边能走
			int t=find(v,min(e[i].f,limit-flow));
			//相当于把流过来的limit分成几部分往后流，用过的就是flow
			//将剩下的与这条边的最大流量取min
			if(!t) dep[v]=-1;//优化：已经没法走，将这个点删掉
			e[i].f-=t;e[i^1].f+=t;
			//更新残留网络，反向边容量等于正向边流量
			flow+=t;
		}
	}
	return flow;
}
int Dinic(){
    int r=0;
	while(bfs()){
		//不断重复：将残留网络分层，
		//在残留网络上找增广路更新答案
		//bfs: 判断有无增广路、将图分层
		int flow;
		while(flow=find(s,INF)) r+=flow;
		//找每一条增广路，加上流量
	}
    return r;
}
```
Dinic 是求最大流最小割最常用的算法，需要尽量理解才能避免实现细节出错，直接背下来很容易写错。

## 例题
其实 Dinic 只是求最大流的工具，大多数问题的精髓在于建模。下面给出几道最大流例题。约定 $(u,v,c)$ 表示一条从 $u$ 到 $v$ 容量为 $c$ 的边。

### [LuoguP2756 - 飞行员配对方案问题](https://www.luogu.com.cn/problem/P2756)
> 求二分图最大匹配，输出方案

~~其实用匈牙利也能过，还自带方案~~

这里我们用网络流来做，重点在建图。建立虚拟源点与汇点，从源点向左部的每个点连一条容量为 $1$ 的边，从右部每个点向汇点连一条容量为 $1$ 的边，这样每个点就可以满足正好使用一次。中间的边按照题目要求连，容量任意，因为已经被前面的连边限制住容量了。建完图跑最大流即可。

输出方案时，遍历右部每个点的入边，如果剩余容量为 $0$ 表示被使用过，将这条边两个端点进行匹配即可。

**[标程](https://yumomeow.github.io/2025/02/24/std/#LuoguP2756)**

### [LuoguP3254 - 圆桌问题](https://www.luogu.com.cn/problem/P3254)
> 有 $m$ 个代表团，$n$ 张桌子，代表团人数与桌子大小有可能不同，把每一位代表安排到一张桌子上，问有没有方案使同一张桌子上没有两个人来自相同的代表团，输出方案。

建立源点 $s$ 与汇点 $t$，$s$ 向每个代表团连一条容量为人数的边，每个代表团向每张桌子连一条容量为 $1$ 的边表示只能向同一个桌子派一个人，每张桌子向 $t$ 连一条容量为桌子大小的边。这样我们就同时满足了代表团人数、桌子大小和桌上同一个代表团只能有一个人的限制。跑最大流即可。

考虑如何统计答案。若最大流小于总人数表示无法被分配，无解。否则，在残量网络上枚举所有表示代表团的点，对每个点枚举出边。若出边容量为 $0$ 表示这条代表团和桌子的连边被使用，输出桌子编号即可。

**[标程](https://yumomeow.github.io/2025/02/24/std/#LuoguP3254)**

### [LuoguP2891 - Dining](https://www.luogu.com.cn/problem/P2891)
> 有 $F$ 种食物和 $D$ 种饮料，每种食物或饮料只能供一头牛享用，且每头牛只享用一种食物和一种饮料。现在有 $n$ 头牛，每头牛都有自己喜欢的食物种类列表和饮料种类列表，问最多能使几头牛同时享用到自己喜欢的食物和饮料。

这题需要用拆点的技巧。对食物、牛、饮料分别建立三列点，源点向食物连一条容量为 $1$ 的边，食物向牛连一条容量任意的边，牛向饮料连一条容量任意的边，饮料向汇点连一条容量为 $1$ 的边。但是这样只能保证食物和饮料只被使用一次，如何保证每头牛只吃一种食物和一种饮料呢？

将每个代表牛的点拆成入点和出点，在它们之间连一条容量为 $1$ 的边，这样就保证了至多只有一份流量流过每头牛。跑最大流即可。

**[标程](https://yumomeow.github.io/2025/02/24/std/#LuoguP2891)**

### [POJ3204 - Ikki's Story I-Road Reconstruction](http://poj.org/problem?id=3204)
> 给定一个流网络，求有几条边满足增大这条边的容量后最大流会增加。

对于这种边我们称为关键边，也是很重要的概念。先求出最大流，然后在残量网络上找边即可。

符合条件的边 $(u,v)$ 必须满足以下性质：
- 该条边满流，若当前不满流也无法继续扩充。
- 存在路径 $(s,u)$ 与 $(v,t)$ 不满流，否则即使增大当前边容量也会被路径上的其他边限制。

对于条件一直接枚举边判断剩余流量即可。对于条件二，分别以 $s$ 和 $t$ 为起点 dfs，这样就可以求出某个点与 $s$ 或 $t$ 之间是否有路径，枚举边的同时，若左端点能到 $s$ 右端点能到 $t$ 则满足答案。
**[标程](https://yumomeow.github.io/2025/02/24/std/#POJ3204)**

### 其他题目
LuoguP2766 - 最长不下降子序列问题  
LuoguP1674 - Secret Milking Machine  
LuoguP2754 - 星际转移问题
UVA563 - Crimewave  
UVA11167 - Monkeys in the Emei Mountain
UVA12125 - March of the Penguins

# 最小割
## 定义与求法
将网络上的一些边删去后，$s$ 与 $t$ 不再连通，$V$ 被分割为两部分 $V_s,V_t$，点集 $(V_s,V_t)$ 即为网络的一个割。定义割的容量为
$$
\sum_{u\in V_s,v\in V_t,(u,v)\in E} c(u,v)
$$
形象地说，还是以水管来举例。假设你是要破坏水管网络的坏蛋，要破坏一些管道使源点与汇点不再联通。因为水管容量越大越粗，肯定要选容量小、好破坏的管道。最小割就是求出你最小需要破坏多少容量的管道才能让源点与汇点不连通。

有定理：图的最大流的流量等于最小割的容量。要求最小割，只需求出最大流即可。

## 例题
### [LuoguP2774 - 方格取数问题](https://www.luogu.com.cn/problem/solution/P2774)
> 给定一个方格图，每个格中都有一个正整数。现要从方格中取数，使任意两个数所在方格没有公共边，且取出的数的总和最大，求出最大的和。

换一个角度思考，如果取了一个方格，那么就禁止取相邻四个方格，其他不限制。所以，如果假定先选择所有方格，再删去不符合条件的，**使删去的格子权值和尽量小**，可能会更好考虑。

对网格图网络流的这种限制来说，**染色**是一个比较好用的技巧。按照横纵坐标和的奇偶性染成黑白两色，类似棋盘格的形态。这样，题目中的条件就变为：**不同颜色的相邻格子不能同时选**。

这样就可以用最小割来求解了。构造一个二分图，白色点放左边，黑色点放右边。$s$ 向白点连一条容量为权值的边，黑点向 $t$ 连一条容量为权值的边，表示**删除这个点需要花的代价**。白点向相邻的黑点连一条容量为无穷的边，因为我们并不需要删除中间的边，它们主要起限制作用。**若不能删除这条边，它连接的白点与黑点至少要删掉一个，才能保证 $s$ 与 $t$ 不连通。**

建完图求最小割即可，就是我们最少要删去的权值，用总权值减去这个数就是答案。

实际上这个问题中求出的最小割称为**二分图的最小权值覆盖**，答案就是**二分图的最大权独立集**。

**[标程](https://yumomeow.github.io/2025/02/24/std/#LuoguP2274)**

### [BZOJ3275 - Number](https://darkbzoj.cc/problem/3275)
> 有 $n$ 个正整数，选择一些数使它们的和最大。若 $a,b$ 同时满足以下条件，则不能同时被选：  
> 1. $\exists c\in N_+,a^2+b^2=c^2$
> 2. $\gcd (a,b)=1$

这个问法与上一题类似，求出和减去能舍弃掉的最小值即可，关键是怎么求。我们可以发现一些有趣的性质：

- 偶数与偶数不能同时被选，因为对于任意两个偶数它们的 $\gcd$ 最小都是 $2$。
- 奇数与奇数不能同时被选，因为当 $a,b$ 为奇数时，它们的平方和在模 $4$ 意义下一定为 $2$，完全平方数在模 $4$ 意义下一定为 $0/1$，不可能相等。

这样我们就可以构造二分图了。从 $s$ 向奇数连边，从 $t$ 向偶数连边，暴力枚举奇数和偶数判是否满足条件，若满足连一条无穷边即可。

**[标程](https://yumomeow.github.io/2025/02/24/std/#BZOJ3275)**

**此处应有一个最大权闭合子图例题，以后再写**

### 其他题目
UVA1515 - Pool Construction

# 费用流
与最大流问题的不同在于，费用流给每一单位的流量增加了一个费用 $d_i$，我们要在**求出满足最大流的情况下消耗的最小费用**。

## EK 算法求费用流
首先为什么不能用 Dinic？因为它同时增广了多条路，我们无法保证费用最小。所以将 EK 算法稍作改造，每次只增广一条路。

对于一个增广路边集 $E$，增广了 $f$ 单位流量，费用即为 $\sum_{i\in E} d_if=f\sum_{i\in E} d_i$。所以我们在求出最大流的同时求出最小费用和即可，$\sum d_i$ 可以在残量网络上用 SPFA 求最短路得到。

我们同样面临一个问题，现在每条边多存了一个费用属性，那反向边的费用是多少？取相反数即可。因为退回一份流量的同时，贡献也会相应减少。

因为使用了 SPFA，算法的复杂度来到了 $O(V^2E^2)$。这里给出 EK 求最大流及最小费用的参考代码：
```cpp
int incf[N],dis[N],pre[N];//incf 走到当前点的最大流，dis 费用最短路
bool vis[N];//SPFA 是否在队列中
struct Edge{int to,nxt,f,w;}e[50010];
void add(int u,int v,int c,int w){
    e[++tot]={v,head[u],c,w};head[u]=tot;
    e[++tot]={u,head[v],0,-w};head[v]=tot;//反向边费用为负
}
bool spfa(){
    queue<int> q;q.push(S);
    memset(vis,0,sizeof(vis));
    memset(dis,0x3f,sizeof(dis));
    dis[S]=0;vis[S]=1;incf[S]=INF;//初始流量为无限
    while(q.size()){
        int u=q.front();q.pop();
        vis[u]=0;
        for(int i=head[u];i;i=e[i].nxt){
            int v=e[i].to;
            if(e[i].f&&dis[v]>dis[u]+e[i].w){
				//距离可以更新并且这条边可以增广
                dis[v]=dis[u]+e[i].w;
                incf[v]=min(incf[u],e[i].f);//更新流量
                pre[v]=i;
                if(!vis[v]) vis[v]=1,q.push(v);
            }
        }
    }
    return dis[T]!=INF;//能到达 T 才有增广路
}
void EK(int &cost,int &flow){
    while(spfa()){
		//统计最小费用与最大流
        cost+=dis[T]*incf[T];//最小费用即为费用最小和乘最大流
		flow+=incf[T];
        for(int i=T;i!=S;i=e[pre[i]^1].to){
            e[pre[i]].f-=incf[T];
            e[pre[i]^1].f+=incf[T];//更新残量网络
        }
    }
    return;
}
```
## 例题
### [LuoguP4015 - 运输问题](https://www.luogu.com.cn/problem/P4015)
> 有 $m$ 个仓库和 $n$ 个零售商店。第 $i$ 个仓库有 $a_i$ 个单位的货物；第 $j$ 个零售商店需要 $b_j$ 个单位的货物。
满足$\sum\limits_{i=1}^{m}a_i=\sum\limits_{j=1}^{n}b_j$。
从第 $i$ 个仓库运送每单位货物到第 $j$ 个零售商店的费用为 $c_{ij}$​​
>
>求最小和最大总费用。

同样可以用二分图来做，与源点和汇点间连的边限制了货物数量，费用为 $0$，图中间连的边限制了每单位货物的费用，容量为无穷，跑最大流即可。

如何求最大总费用？把所有费用取反即可。

**[标程](https://yumomeow.github.io/2025/02/24/std/#LuoguP4015)**

### [LuoguP4012 - 深海机器人问题](https://www.luogu.com.cn/problem/P4012)
>深海资源考察探险队的潜艇将到达深海的海底进行科学考察。潜艇内有多个深海机器人，潜艇到达深海海底后，深海机器人将离开潜艇向预定目标移动。深海机器人在移动中还必须沿途采集海底生物标本。
>
>沿途生物标本由最先遇到它的深海机器人完成采集。每条预定路径上的生物标本的价值是已知的，而且生物标本只能被采集一次。  
给定所有起点和终点以及以它们为起点或终点的机器人数量，限定深海机器人只能从其出发位置沿着向北或向东的方向移动，而且多个深海机器人可以在同一时间占据同一位置。
>
>用一个 $P\times Q$ 网格表示深海机器人的可移动位置。西南角的坐标为 $(0,0)$，东北角的坐标为 $(Q,P)$。
![](https://cdn.luogu.com.cn/upload/pic/12215.png)   
给定每个深海机器人的出发位置和目标位置，以及每条网格边上生物标本的价值，计算深海机器人的最优移动方案，使深海机器人到达目的地后，采集到的生物标本的总价值最高。

首先所有贡献都在路径上，不用考虑拆点之类的东西。但是每个生物标本只能被采集一次，路径却可以重复走，怎么办？

每两个点之间连两条边即可。一条容量为 $1$，费用为生物标本的价值，一条容量为 $\infty$，费用为 $0$。这样第一次走会获得贡献，以后也可以重复走，但无法获得贡献。

在相邻点之间连边，从源点向所有起点连一条容量为机器人数量，费用为 $0$ 的边，从所有终点向汇点连一条相同的边，求最大费用最大流即可。

**[标程](https://yumomeow.github.io/2025/02/24/std/#LuoguP4012)**

---
**参考资料**

[网络流详解: 从入门到放弃 - rvalue's blog](https://blog.rvalue.moe/10650849/)

[网络流 - OI Wiki](https://oiwiki.org/graph/flow/max-flow/)

[网络流 - 维基百科](https://zh.wikipedia.org/wiki/%E7%BD%91%E7%BB%9C%E6%B5%81)