---
title: 数据结构题单总结
date: 2025-02-21 14:42:00
excerpt: wyq布置的数据结构题。。
categories: 
	- 题单总结
tags:
	- 数据结构
	- 并查集
	- 树状数组
	- 线段树
	- 平衡树
	- 分块
	- 莫队
	- 主席树
	- 根号分治
	- 树上差分
	- 扫描线
	- 李超线段树
	- K-D树
	- Trie树
---

题目顺序按照涉及的算法进行了微调，有的题没有写进去。

## [1. LuoguP4185 - MoooTube G](https://www.luogu.com.cn/problem/P4185)

**并查集**

#### 题意
给定一棵 $n$ 个结点的树，每条边有边权，定义任意两个结点的相关度为两点之间路径上的最小权值。有 $Q$ 次询问，每次给定 $k_i,v_i$，仅当两个结点相关度 $\ge k_i$ 时相关。求与结点 $v_i$ 相关的结点数量。

#### 题解
显然询问可以离线，$k_i$ 逐渐下降的过程中相关的点也越来越多，转化为并查集加边过程，将询问按 $k_i$ 排序，每次连接权值为 $k_i$ 的所有边，答案即为 $v_i$ 所在联通块大小。

**[标程](https://yumomeow.github.io/2025/02/24/std/#LuoguP4185)**

## [2. LuoguP1955 - 程序自动分析](https://www.luogu.com.cn/problem/P1955)

**并查集**

#### 题意
有一些变量 $x_1,x_2,x_3,\cdots$，给定 $n$ 个约束条件形如 $x_i = x_j$ 或 $x_i \not = x_j$，判定这些约束条件能否同时被满足。

#### 题解
注意到相等的限制维护了一些相等变量的集合，使用并查集，先合并相等的限制，对于不等的限制，若先前已经判定相等（在同一集合内），则不可能被满足。

**[标程](https://yumomeow.github.io/2025/02/24/std/#LuoguP1955)**

## [3. LuoguP4479 - 第k大斜率](https://www.luogu.com.cn/problem/P4479)

**树状数组**

#### 题意
二维平面上给定 $n$ 个不同的点，任意两点确定一条直线，求所有直线中斜率第 $k$ 大的。

#### 题解
$(x_i,y_i),(x_j,y_j)$ 所连直线的斜率 $=\frac{y_j-y_i}{x_j-x_i}$。二分斜率，每次检查 $>$ mid的斜率个数。考虑如何快速求解。

设 $x_j>x_i$，则所求直线满足
$$\frac{y_j-y_i}{x_j-x_i}>mid$$
$$y_j-y_i>mid(x_j-x_i)$$
$$y_j-mid\times x_j>y_i-mid\times x_i$$
按照 $y-mid\times x$ 从小到大排序，树状数组记录这个值，依次扫描，更新答案并将当前点添加到树状数组中即可，类似逆序对的求解过程，这种过程求解的问题叫做二维偏序。

时间复杂度 $O(n \log^2 n)$。

**[标程](https://yumomeow.github.io/2025/02/24/std/#LuoguP4479)**

## [4. LuoguP1966 - 火柴排队](https://www.luogu.com.cn/problem/P1966)

**树状数组**

#### 题意
给定两个数列 $a,b$，他们的距离定义为 $\sum (a_i-b_i)^2$。

求交换同一数列中相邻元素使距离最小的最小交换次数。

#### 题解
显然将两数列中排名相同的数放到同一位置可以构造出最小距离，考虑如何求交换次数。

假设 $a$ 数列不动，我们要动 $b$ 数列使它对齐。预处理出 $b$ 数列中每个数应该到达的位置数列 $l$，排序求逆序对即可。

**[标程](https://yumomeow.github.io/2025/02/24/std/#LuoguP1966)**

## [5. LuoguP3605 - Promotion Counting](https://www.luogu.com.cn/problem/P3605)

**树状数组**

#### 题意
给定一棵 $n$ 个点的树，点有点权，求以每个点为根的子树内权值大于根的权值的点的个数。

#### 题解
我们可以对树进行 $dfs$。每次搜到一个点 $x$ 时，记录 $x$ 以前搜索到的点中 $p_i>p_x$ 的个数为 $cnt_1$。搜索完 $x$ 的子树后回溯时，记录满足条件的点数为 $cnt_2$。用 $cnt_2-cnt_1$ 即可。使用树状数组统计答案。

**[标程](https://yumomeow.github.io/2025/02/24/std/#LuoguP3605)**

## [6. LuoguP1972 - HH的项链](https://www.luogu.com.cn/problem/P1972)

**树状数组**

#### 题意
给定一个数列，每次询问区间 $[l,r]$ 中有多少不同的数。

#### 题解
将询问离线后从右往左扫描数列，记录每个数当前最后一次出现的位置，在这个位置记录贡献。多次出现则删除之前的贡献。每次处理以当前点为左端点的区间，在右端点处求贡献的前缀和，即为区间答案。因为记录的是最后出现的位置，因此所有贡献一定被包含在了右端点左边。

**[标程](https://yumomeow.github.io/2025/02/24/std/#LuoguP1972)**

## [7. LuoguP4113 - 采花](https://www.luogu.com.cn/problem/P4113)
**树状数组**
#### 题意
给定一个数列，每次询问区间 $[l,r]$ 中有多少出现两次及以上的数。
#### 题解
把询问离线后从左往右扫描，记录每个数上次和上上次出现的位置，在上上次出现的位置记录贡献。每次处理以当前点为右端点的区间，答案即为 $[l,r]$ 的贡献之和，使用树状数组维护贡献。

**[标程](https://yumomeow.github.io/2025/02/24/std/#LuoguP4113)**

## [8. LuoguP3586 - LOG](https://www.luogu.com.cn/problem/P3586)
**平衡树**
#### 题意
维护一个长度为 $n$ 的序列，一开始都是 $0$，支持单点修改以及在这个序列上每次选出 $c$ 个正数，并将它们都减去 $1$，问能否进行 $s$ 次操作。
#### 题解
设 $≥s$ 的数有 $x$ 个，$<s$ 的数和为 $sum$，能够成功应该满足 $sum≥(c−x)\times s$。如果不满足显然不行，满足后要证明每次取有至少c个数。

考虑 $sum$，最少的时候有 $⌈\frac{sum}{s-1}⌉$ 个数，如果满足 $sum≥(c−x)∗s$，则 $⌈\frac{sum}{s-1}⌉>c−x$，此时一定有解。

考虑如何维护 $<s$ 的数的和 $sum$ 与 $\ge s$ 的数的个数 $x$，可以使用splay。将 $s$ 的前驱转到根，$sum$ 即为 $sum_{root}-sum_{rs_{root}}$，$x$ 即为 $siz_{rs_{root}}$。

**[标程](https://yumomeow.github.io/2025/02/24/std/#LuoguP3586)**

## [9. LuoguP4588 - 数学计算](https://www.luogu.com.cn/problem/P4588)
**线段树**
#### 题意
给定一个初始值为 $1$ 的数 $x$，每次操作将 $x$ 变为 $x\times m$ 或撤销之前的某一次操作。
#### 题解
最终的数可以写作 $m_1\times m_2\times m_3\times \cdots \times m_n$，因此我们可以建一棵线段树储存每个因数并记录区间乘积，即为答案。初始每个因数均为 $1$，操作1即为单点修改，撤销时把对应位置的值修改为 $1$ 即可。

**[标程](https://yumomeow.github.io/2025/02/24/std/#LuoguP4588)**

## [10. LuoguP4198 - 楼房重建](https://www.luogu.com.cn/problem/P4198)
**线段树**
#### 题解
显然能看到楼房顶端与原点连线的斜率必定单调递增，考虑将高度转化为斜率并用线段树维护。

具体地，每个线段树节点维护区间 $max$ 与区间答案 $len$。难点在于如何进行pushup操作。

维护 $len$ 时，首先左儿子答案必定包含于大区间答案中，显然。对于右儿子我们递归处理。

对于每个区间传入其必须大于的值 $lx$，即左区间的最大值。把右区间分为 $s1,s2$ 分开考虑。如果 $s1$ 最大值 $≤ls$，则没有贡献，递归 $s2$。如果 $s1$ 的最大值大于 $lx$，那么 $s2$ 中剩下的在原区间中做贡献的项一定能贡献到最终答案中。之后去递归 $s1$。

时间复杂度 $O(n \log^2 n)$。

**[标程](https://yumomeow.github.io/2025/02/24/std/#LuoguP4198)**

## [11. LuoguP3870 - 开关](https://www.luogu.com.cn/problem/P3870)
**线段树**
#### 题意
初始给定一个全 $0$ 序列，要求将区间内所有数取反和查询区间内 $1$ 的个数。
#### 题解
使用线段树维护，记录区间内 $1$ 的个数，每次对区间取反就是将 $sum$ 变为 $(r-l+1)-sum$。维护懒标记时也直接取反即可。

**[标程](https://yumomeow.github.io/2025/02/24/std/#LuoguP3870)**

## [12. LuoguP5490 - 矩形面积并](https://www.luogu.com.cn/problem/P5490)
**线段树 扫描线**
#### 题意
求 $n$ 个四边平行于坐标轴的矩形的面积并。
#### 题解
扫描线模板题。将矩形的所有横边离线，记录 $x_l,x_r,y$。将下边缘标记为入边，上边缘标记为出边，答案即可拆分为两条线段之间的矩形的面积之和。

自下而上扫描线段，扫描到入边时记录该条线段，扫描到出边删除该条线段。用线段树记录当前存在的线段的长度并 $x$，每次扫描到一条线段时更新 $x$ 并在答案中加上 $x\times (y_{i+1}-y_i)$。

实现细节中，注意线段树的每个叶子节点记录的是区间 $[l,r+1]$ 的信息，这样每个点保留的就是一条线段而不是一个端点了。因为我们将横坐标离散化了，因此一个结点的实际左右端点需要单独记录在结构体中。

**[标程](https://yumomeow.github.io/2025/02/24/std/#LuoguP5490)**

## [13. LuoguP1502 - 窗口的星星](https://www.luogu.com.cn/problem/P1502)
**线段树 扫描线**
#### 题意
二维平面上有 $n$ 个点，点有点权，求在平面内框一个 $H\times W$ 的矩形，矩形内点权和的最大值。
#### 题解
注意到如果以每个点为左下角建立一个 $H\times W$ 的矩形，如果两个点的矩形有交集就代表它们可以同时被选中，因为可以将矩形框在左下角的星星上，其他星星必定在交集的左下角，因此也可以被框住。

考虑维护交集的权值和。建立完所有矩形后自下而上扫描线段，添加进线段树时将区间 $[x_l,x_r]$ 的点都增加矩形代表点的权值，扫描到出边删除即可，每次添加时更新区间最大值的最大值即为答案。

**[标程](https://yumomeow.github.io/2025/02/24/std/#LuoguP1502)**

## [14. LuoguP4097 - Segment](https://www.luogu.com.cn/problem/P4097)
**线段树 李超线段树**
#### 题意
在二维平面内维护两个操作：

1. 给定线段的两个端点，将它加入到平面内。
2. 给定 $k$，求与直线 $x=k$ 相交的线段中交点纵坐标最大的线段的编号。

#### 题解
李超线段树模板题。求出每条线段的解析式 $f(x)=kx+b$，用线段树维护 $x$ 轴上所有点的答案。线段树每个结点记录的是区间 $[l,r]$ 中点处的答案。

加入一条线段时，递归更新。扫描到区间 $[l,r]$ 时，
1. 若区间中没有线段，直接将它作为答案，返回。
2. 若它比原线段更优，将它作为当前点答案。
3. 记录在上一步中被淘汰的线段为 $a$，胜出的为 $b$。若在右端点处 $a$ 比 $b$ 优，则它们一定在左区间中产生了交点，递归更新左区间答案，右区间同理。可以参考以下代码：
```cpp
void update(int u,int l,int r,int L,int R,int k){
	if(L<=l&&r<=R){
		if(!id[u]) return id[u]=k,void();//还没有过
		if(f[k].q(mid)-f[id[u]].q(mid)>eps) swap(k,id[u]);
		if(f[k].q(l)-f[id[u]].q(l)>eps||(f[k].q(l)==f[id[u]].q(l)&&k<id[u])) update(ls,l,mid,L,R,k);
		if(f[k].q(r)-f[id[u]].q(r)>eps||(f[k].q(r)==f[id[u]].q(r)&&k<id[u])) update(rs,mid+1,r,L,R,k);
		return;
	}
	if(L<=mid) update(ls,l,mid,L,R,k);
	if(R>mid) update(rs,mid+1,r,L,R,k);
}
```

查询时，由于每个点记录的是点上的答案，无法进行向下更新的操作，因此我们需要从根节点向下递归到查询的点，在路径上不断取 $max$ 即为答案。可以参考以下代码：
```cpp
pair<int,int> query(int u,int l,int r,int k){//返回的是编号和值，编号用于更新答案
	pair<int,int> res;
	if(id[u]) res={f[id[u]].q(k),id[u]};
	if(l==r) return res;
	if(k<=mid) res=_max(query(ls,l,mid,k),res);
	else res=_max(query(rs,mid+1,r,k),res);
	return res;
}
```
**[标程](https://yumomeow.github.io/2025/02/24/std/#LuoguP4097)**

## [15. LuoguP4556 - 雨天的尾巴](https://www.luogu.com.cn/problem/P4556)
**线段树 线段树合并**
#### 题意
给定一棵树，每次在点 $x$ 到点 $y$ 路径上的每个点增加一个数 $z$，求所有操作完毕后每个点上最多的数。
#### 题解
线段树合并模板题。使用树上差分思想，每次操作可以转化为在 $(1,x),(1,y)$ 上增加 $z$，在 $(1,lca(x,y)),(1,fa_{lca(x,y)})$ 上减少 $z$，从下向上合并后再执行当前点上的操作，此时记录的即为当前点的答案。

在每个点上我们开一棵权值线段树记录每个数的出现次数，于是每次更新就需要将两棵权值线段树合并。如果暴力合并将每个点都相加合并一次复杂度为 $O(n)$，无法接受。但如果是动态开点的线段树，合并时有更加高效的方法。

具体来说，将线段树 $y$ 合并到 $x$ 上，从上到下递归。如果 $x$ 没有左儿子但 $y$ 有，直接将 $y$ 的左儿子接到 $x$ 的左儿子上，就不用向下递归了，如果都有则递归处理。右儿子同理。可以参考以下代码：
```cpp
void merge(int p1,int p2,int l,int r){
	if(l==r){
		ma[p1]=ma[p1]+ma[p2];
		return;
	}
	if(s[p1][0]&&s[p2][0]) merge(s[p1][0],s[p2][0],l,mid);
	else if(s[p2][0]) s[p1][0]=s[p2][0];
	if(s[p1][1]&&s[p2][1]) merge(s[p1][1],s[p2][1],mid+1,r);
	else if(s[p2][1]) s[p1][1]=s[p2][1];
	ma[p1]=max(ma[s[p1][0]],ma[s[p1][1]]);
}
```

深搜整棵树，回溯过程中依次将当前点的所有儿子合并到当前点的权值线段树上，然后执行当前点的加减操作，执行完毕后记录当前点的答案即可。

**[标程](https://yumomeow.github.io/2025/02/24/std/#LuoguP4556)**

## [16. LuoguP3919 - 可持久化线段树1](https://www.luogu.com.cn/problem/P3919)
**线段树 主席树**
#### 题意
维护一个数列，要求支持在某个历史版本上修改某一个位置上的值、访问某个历史版本上的某一位置的值。每次操作生成一个新的版本。
#### 题解
主席树模板题。主席树即为能维护区间历史信息的一种线段树变体。题目中支持的操作可以用线段树实现，但如果要访问历史版本，通常的想法是每次操作复制一棵完整的线段树，但这样的复杂度无法接受。

注意到每次修改时，仅改变了从根节点到修改点路径上的 $\log n$ 个点，把整棵线段树复制过去显然是不划算的。于是我们仍然对每次操作建一个新的根，但是修改过程中某个点没有更改的子树，就直接指向历史版本的那个子树的位置，对于更改过的再新建结点。这样每次修改的复杂度就是 $O(\log n)$。

具体实现中，update函数传入的就是一个地址，这样就能直接方便地修改某个点的编号。每次修改时先把新根设为历史版本的根传入函数，新建新结点复制历史点的信息后，再递归需要修改的点。这样需要修改的儿子就在下一层递归被自动赋给了当前点记录的左儿子信息。可以参考以下代码：

```cpp
//&u 初始传入历史版本的根
void change(int &u,int l,int r,int U,int k){
	tr[++tot]=tr[u]; u=tot;
	if(l==r){
		tr[u].val=k;
		return;
	}
	if(U<=mid) change(tr[u].ls,l,mid,U,k);
	else change(tr[u].rs,mid+1,r,U,k);
	return;
}
```
**[标程](https://yumomeow.github.io/2025/02/24/std/#LuoguP3919)**

## [17. LuoguP3402 - 可持久化并查集](https://www.luogu.com.cn/problem/P3402)
**线段树 主席树**
#### 题意
给定 $n$ 个集合，集合 $i$ 初始包含数 $i$。要求支持合并两集合、回到之前操作以及询问两数是否属于同一集合。
#### 题解
注意到并查集合并两集合，发生变化的仅是其中一个集合根节点的父亲。因此只需要对 $fa$ 数组可持久化即可。每次回退时将这次操作的根节点指向历史版本的根。合并操作就在上一步的基础上进行。

如果要实现可持久化，就不能用路径压缩来优化，因为每次执行 $find$ 操作都会改变好多个点的父亲。因此我们需要用按秩合并优化，此时就需要多记录每个集合的 $size$。这个数组也需要可持久化。

注意，$fa$ 和 $size$ 并不能在一棵主席树上记录，因为每次合并更改旧根的 $fa$ 和新根的 $size$。所以需要开两个。

**[标程](https://yumomeow.github.io/2025/02/24/std/#LuoguP3402)**

## [18. LuoguP3834 - 可持久化线段树2](https://www.luogu.com.cn/problem/P3834)
**线段树 主席树**
#### 题意
给定一个数列，每次查询区间 $[l,r]$ 的第 $k$ 小值。
#### 题解
查询固定区间的第 $k$ 小值可以用权值线段树维护，查询时如果左子树的数量 $s\ge k$ 则在左子树中找第 $k$ 大，否则在右子树中找第 $k-s$ 大。

但是问题中的区间是不固定的，如何快速获取询问区间的权值线段树？

注意到权值线段树满足类似前缀和的性质，即区间 $[l,r]$ 对应的树可以由区间 $[1,r]$ 和区间 $[1,l-1]$ 对应的树相减得到，于是我们需要维护每个位置的前缀权值线段树。

并不需要对每个位置建一棵新树，我们可以使用主席树的技巧。从左往右建树时，每次仅多了当前点的信息，于是我们可以只添加根节点到当前点的数路径上的 $\log n$ 个结点，其余点直接指向历史版本即可。使用主席树维护

每次查询时，不需要真正相减建出一棵新树，只需同时在两棵树上递归，在每个位置上将两棵树的点相减即可。可以参考以下代码：
```cpp
int query(int u,int v,int l,int r,int k){
	if(l==r) return l;
	int s=tr[tr[u].ls].cnt-tr[tr[v].ls].cnt;
	if(s>=k) return query(tr[u].ls,tr[v].ls,l,mid,k);
	else return query(tr[u].rs,tr[v].rs,mid+1,r,k-s);
}
```
**[标程](https://yumomeow.github.io/2025/02/24/std/#LuoguP3834)**

## [19. LuoguP2633 - Count on a tree](https://www.luogu.com.cn/problem/P2633)
**线段树 主席树**
#### 题意
给定一棵树，点有点权，每次询问 $u,v$ 路径上第 $k$ 小点权。
#### 题解
本题与上一题类似，只是换到了树上。考虑如何使用前缀和技巧获取 $u,v$ 路径上对应的权值线段树。

仍然使用主席树，从根节点开始搜索，每个点在它父亲点的基础上增加它的信息。这样我们就可以快速查询。设点 $i$ 对应的前缀权值线段树为 $c_i$，则 $u,v$ 路径上的权值线段树即为 $c_u+c_v-c_{lca(u,v)}-c_{fa_{lca(u,v)}}$。在它上面查询即可。

**[标程](https://yumomeow.github.io/2025/02/24/std/#LuoguP2633)**

## [20. LuoguP3302 - 森林](https://www.luogu.com.cn/problem/P3302)
**线段树 主席树**
#### 题意
给定一片森林，要求支持查询两点路径上第 $k$ 小权值以及在两点之间连边，保证连边后仍是森林。
#### 题解
这题和上一题的区别在于增加了连边（合并两棵树）的操作。如果要用主席树维护 $k$ 小权值，合并就必须要暴力合并。每次合并在两点间连一条边，并将小树的根节点的父亲设置为大树的根节点。此时小树上主席树应该发生变化，我们直接从小树的根开始暴力dfs重构即可。

**[标程](https://yumomeow.github.io/2025/02/24/std/#LuoguP3302)**

## [21. LuoguP4585 - 火星商店问题](https://www.luogu.com.cn/problem/P4585)
**Trie树 主席树**

太难以后写

## [22. LuoguP4148 - 简单题](https://www.luogu.com.cn/problem/P4148)
**K-D树**
#### 题意
在二维平面内支持单点加以及求某个矩形内数字的和。
#### 题解
K-D树模板题，K即为空间的维数，绝大多数情况都是二维。K-D树即是一种将K维空间用树维护的数据结构。树上的每个结点代表平面内的某个点。

具体来说，每个结点维护的信息由先前的区间变为了某个点，每次将矩形用一条经过中位数的点并且与x轴平行或与y轴平行的直线切开，左子树和右子树分别存储切开的两个矩形之内的点，相邻两层交替进行。

单点修改时，像线段树那样每次判断需要修改的点在左儿子代表的矩形内还是在右儿子代表的矩形内，直到找到需要修改的点。可以参考以下程序：
```cpp
void insert(int &u,Point k,int d){
	//tp即为当前矩形储存的点
    if(!u){u=newnode(),ls(u)=rs(u)=0,tr[u].tp=k,pushup(u);return;}
    if(k.pos[d]<=tr[u].tp.pos[d]) insert(ls(u),k,d^1);
    else insert(rs(u),k,d^1);
    pushup(u);
    check(u,d);
}
```

查询矩形内数的和时，也与线段树类似，如果当前矩形包含在查询矩形中则直接返回，否则递归它的两个儿子。可以参考以下程序：
```cpp
int query(int u,int x1,int y1,int x2,int y2){
    if(!u) return 0;
    int res=0;
    if(in(x1,y1,x2,y2,tr[u].mi[0],tr[u].mi[1],tr[u].ma[0],tr[u].ma[1])) return tr[u].sum;
    if(out(x1,y1,x2,y2,tr[u].mi[0],tr[u].mi[1],tr[u].ma[0],tr[u].ma[1])) return 0;
    if(in(x1,y1,x2,y2,tr[u].tp.pos[0],tr[u].tp.pos[1],tr[u].tp.pos[0],tr[u].tp.pos[1])) res+=tr[u].tp.w;
    res+=query(ls(u),x1,y1,x2,y2)+query(rs(u),x1,y1,x2,y2);
    return res;
}
```

特别注意的是，不同于线段树，由于单点修改时修改的点未被记录进去，存在点的插入操作，每个子树内的点数量就有可能不同。如果数量差距过大就会导致无法保证复杂度。于是我们手动设置一个 $\alpha=0.75$，当某个儿子的数量比上父亲的数量超过这个值时，我们直接将父亲代表的这个大矩形推倒重新切割。类似替罪羊树。可以参考以下代码：
```cpp

int D;
bool operator < (Point a,Point b){
    return a.pos[D]<b.pos[D];
}//当前处理的哪一维
void pia(int u,int num){
    if(ls(u)) pia(ls(u),num);
    p[tr[ls(u)].siz+num+1]=tr[u].tp,rub[++top]=u;
    if(rs(u)) pia(rs(u),num+tr[ls(u)].siz+1);
}
int rebuild(int l,int r,int d){
    if(l>r) return 0;
    int mid=(l+r)>>1,k=newnode();
    D=d;nth_element(p+l,p+mid,p+r+1);//取区间中位数切割
    tr[k].tp=p[mid];
    tr[k].ls=rebuild(l,mid-1,d^1);
    tr[k].rs=rebuild(mid+1,r,d^1);
    pushup(k);
    return k;
}
void check(int &u,int d){
    if(tr[ls(u)].siz>tr[u].siz*0.75||tr[rs(u)].siz>tr[u].siz*0.75){
        pia(u,0);u=rebuild(1,tr[u].siz,d);
    }
}
```
**[标程](https://yumomeow.github.io/2025/02/24/std/#LuoguP4148)**

## [23. LuoguP3710 - 方方方的数据结构](https://www.luogu.com.cn/problem/P3710)
**平衡树 K-D树**
#### 题意
给定一个数列，要求支持区间加、区间乘、单点查询和撤销以前的某次操作。
#### 题解
要求支持撤销操作，就不方便对序列直接维护，因为每次撤销对后续的影响是不确定的。

考虑对询问离线，建立一个以下标为横轴，时间为纵轴的二维平面。这样，每一个询问就可以抽象为一个点放到这个平面上。

每个询问可能会被撤销，所以它的影响范围仅限于某个区间上的某个时间段，放到平面内就是一个矩形。

离线所有问到的点，放到平面上以后对平面建立K-D树，每次修改时就可以直接在某个大的矩形上打标记，按照时间处理操作和询问，询问时递归直到找到具体的点即可，在递归的途中将大矩形的标记pushdown。由于我们是离线所有询问后先建的树，后面处理修改时并没有对点的插入，因此平衡性不会破坏，并不需要重建操作。

**[标程](https://yumomeow.github.io/2025/02/24/std/#LuoguP3710)**

## [24. LuoguP2801 - 教主的魔法](https://www.luogu.com.cn/problem/P2801)
**分块**
#### 题意
维护一个数列，支持区间加与查询区间内 $\ge k$ 的数的个数。
#### 题解
$k$ 是变化的，所以不能使用线段树之类的数据结构维护。这种不可合并的问题可以使用分块。

具体地，将整个区间分成若干块，每块长度为 $\sqrt n$。预处理每块的左端点 $L_i$，右端点 $R_i$ 和每个点属于的块 $bel_i$。在处理过程中不断维护每个块内部都排好序的数列 $b$。

将 $[l,r]$ 同时加上 $k$，可以将区间分成三段处理。
- 对于区间开头的没有被完全覆盖的块 $bel_l$，直接暴力将 $[l,R_{bel_l}]$ 每个数加上 $k$。之后对块重新排序。区间末尾没被完全覆盖的块同理。
- 对于被区间完全覆盖的块，对每个块维护一个标记 $add$，直接对 $add$ 加上 $k$ 即可。区间内数 $i$ 的实际值即为 $i+add$。

特别地，如果修改区间的左右端点属于同一个块，暴力修改后排序即可。

查询时同样，对于前后未被覆盖的块暴力遍历统计，对于被完全覆盖的块，排序后在内部二分即可。

**[标程](https://yumomeow.github.io/2025/02/24/std/#LuoguP2801)**

## [25. LuoguP3203 - 弹飞绵羊](https://www.luogu.com.cn/problem/P3203)
**分块**
#### 题解
使用分块，对每个点维护跳出该块需要的次数以及跳出该块后到达的点。这个可以 $O(n)$ 预处理。修改时直接将块内所有点暴力重构一遍即可。

询问时一块一块跳，每次累加答案直到跳出去。

**[标程](https://yumomeow.github.io/2025/02/24/std/#LuoguP3203)**

## [26. LuoguP3863 - 序列](https://www.luogu.com.cn/problem/P3863)
**分块**
#### 题意
给定一个序列，要求支持区间加与查询某个位置的数在过去多长时间不小于 $y$。第 $i$ 次操作发生在第 $i$ 秒。
#### 题解
绝世好题。

我们可以把查询离线，从左到右按顺序处理每个位置上的查询。对于每个数，将时间分块，记录每个时间点它的值。这样查询时只需要在每个块内二分即可。

考虑如何处理修改。如果对每个数都重新建块并依次更新每一个操作，时间复杂度显然不支持。注意到我们是从左到右依次处理每个数，这样区间修改就可以用类似差分的方式实现。

具体地，我们并不需要在每个位置重新初始化，只需要在查询下一个数时加上两个数的差即可，这样上一个数的修改就可以保留到下一个数而不是重新修改一次。所以只需要在修改区间的开头加上这个数，之后每个位置都继承上一个位置的修改，在区间末尾再减去这个数即可。

**[标程](https://yumomeow.github.io/2025/02/24/std/#LuoguP3863)**

## [27. LuoguP1975 - 排队](https://www.luogu.com.cn/problem/P1975)
**分块**
#### 题意
给定一个序列，要求交换两个数以及查询每次交换后的逆序对数。
#### 题解
注意到当交换两个数 $a_i$ 和 $a_j$ 时，仅对区间 $[i,j]$ 中的数贡献的逆序对数产生了影响，区间外的数并没有影响，因为它们相对 $i,j$ 的位置没有变。

于是我们只需要统计 $[i,j]$ 的答案变化即可。设 $i<j$。

先看位置 $i,j$。如果 $a_i<a_j$，交换后 $ans++$，反之 $ans--$。

再考虑其它的位置，设当前位置为 $x$，分四种情况：
- $a_x>a_i,ans++$
- $a_x<a_i,ans--$
- $a_x>a_j,ans--$
- $a_x<a_j,ans++$

考虑如何快速统计区间内的答案，使用分块。对于整块的统计，排序后直接二分即可。分散的就暴力遍历求解。时间复杂度 $O(n \sqrt n)$。

**[标程](https://yumomeow.github.io/2025/02/24/std/#LuoguP1975)**

## [28. LuoguP1903 - 数颜色 / 维护队列](https://www.luogu.com.cn/problem/P1903)
**分块 莫队**
#### 题意
给你一个序列，要求支持查询区间内有多少不同的数以及单点修改
#### 题解
本题区间查询的部分可以用普通莫队解决，但是还增加了修改操作。因为并没有强制在线，我们可以把修改操作也按照时间离线，每次查询定位到区间后再根据当前的时间决定改回去或者继续修改。此时将块长定为 $n^{\frac{2}{3}}$ 最优。按时间修改可以参考如下代码：
```cpp
while(ls[i].t<t){
	int pla=cg[t].pla;
	if(l<=pla&&pla<=r)num-=!--p[a[pla]];
	a[pla]=cg[t--].pre;
	if(l<=pla&&pla<=r)num+=!p[a[pla]]++;
};
while(ls[i].t>t){
	int pla=cg[++t].pla;
	if(l<=pla&&pla<=r)num-=!--p[a[pla]];
	a[pla]=cg[t].suc;
	if(l<=pla&&pla<=r)num+=!p[a[pla]]++;
};
```
时间复杂度 $O(n^{\frac{5}{3}})$。

**[标程](https://yumomeow.github.io/2025/02/24/std/#LuoguP1903)**

## [29. LuoguP1494 - 小Z的袜子](https://www.luogu.com.cn/problem/P1494)
**分块 莫队**
#### 题意
给定一个序列，每次在区间内随机抽取两个不同位置的数，求有多大概率数值相同。数的值域 $N=1e5$。
#### 题解
将询问离线，对于每个区间，取到同样颜色的方案数为 $\sum _{i=1}^N cnt_i\times cnt_{i-1}$，总方案数为 $len\times len-1$，考虑如何维护前者。

使用莫队处理即可。假设我们已经处理好区间 $[l,r]$，下一步求区间 $[l,r+1]$，加入了位置 $r+1$ 的数，设它为 $x$，那么答案应该加上 $(cnt_x+1)*cnt_x-cnt_x*(cnt_x-1)$，之后更新 $cnt_x$，删除同理。

**[标程](https://yumomeow.github.io/2025/02/24/std/#LuoguP1494)**

## [30. LuoguP2709 - 小B的询问](https://www.luogu.com.cn/problem/P2709)
**分块 莫队**
#### 题意
给定一个数列，值域为 $[1,k](k\le 5\times 10^4)$，每次给定区间 $[l,r]$，求 $\sum_{i=1}^k cnt_i^2$。$cnt_i$ 表示数字 $i$ 在区间内的出现次数。
#### 题解
与上一题十分类似，扩展区间时直接减去 $cnt_i^2$，加上 $(cnt_i+1)^2$，更新 $cnt_i$ 即可。

**[标程](https://yumomeow.github.io/2025/02/24/std/#LuoguP2709)**

## [31. LuoguP3674 - 小清新人渣的本愿](https://www.luogu.com.cn/problem/P3674)
**分块 莫队 bitset**
#### 题意
给定一个数列，每次询问一个区间是否可以选出两个数它们的差为 $x$，或者询问一个区间是否可以选出两个数它们的和为 $x$，或者询问一个区间是否可以选出两个数它们的乘积为 $x$。
#### 题解
考虑对固定区间怎么做，然后用莫队维护即可。

如果序列中某两个数 $a-b=x$，移项得 $a=x+b$，只要 $a$ 和 $a-x$ 同时存在即可满足。我们可以使用 bitset，每一位记录这个数是否出现过。将原数列的 bitset 左移 $x$ 位，和第 $i-x$ 位对齐的就是第 $i$ 位。两个 bitset 按位与，只要有一个位置是 1 就可以。

如果序列中存在两个数 $a+b=x$，只要 $a$ 和 $x-a$ 同时存在即可满足。使用另一个 bitset 每一位记录 $N-a$ 是否出现过（$N$ 为值域），每次查询时将它右移 $N-x$ 位，和第 $i$ 位对齐的就是第 $x-i$ 位，做一次按位与运算即可。

对于乘法，我们直接枚举积的约数。

**[标程](https://yumomeow.github.io/2025/02/24/std/#LuoguP3674)**

## [32. LuoguP3709 - 大爷的字符串题](https://www.luogu.com.cn/problem/P3709)
**分块 莫队**
#### 题解
要从区间中每次取一个严格上升序列，问最少取几次，显然仅与出现次数最多的数有关，因为要把它一个一个取走。于是问题转化为求区间众数。

用莫队维护，维护两个数组，$cnta$ 表示区间内数的桶，$cntb$ 表示 $cnta$ 的桶。每次往区间里加入一个数，如果加完还是小于当前 $ans$ 不用管，否则更新 $ans$。从区间中删除一个数时，如果当前数是众数才有影响，但如果众数不止一个，删掉之后还有其他的众数，不需要更新。

**[标程](https://yumomeow.github.io/2025/02/24/std/#LuoguP3709)**

## [33. SP10707 - Count on a tree II](https://www.spoj.com/problems/COT2/)
#### 题意
给定一棵树，点有点权，每次询问 $u,v$ 路径上不同点权数。
#### 题解
如果在一个序列上，这个题显然可以用莫队来解决。考虑将树转化为序列。

在 dfs 这棵树时，每次进入一个结点和回溯到这个结点时都记录一次，把所有的结点放到一个序列上，形成了欧拉序。例如：

![](/img/DS-problem-list-summary/63138.jpg)

它的欧拉序就是 $(1,2,4,5,5,6,6,7,7,4,2,3,3)$。第 $i$ 个数第一次出现位置为 $st_i$，第二次为 $ed_i$。

每次询问时分为两种情况：
- $u$ 与 $v$ 在同一子树中，如 $u=6,v=2$。取出区间 $[st_2,st_6]$，即 $(2,4,5,5,6)$，容易发现只有出现一次的有贡献，因为出现两次代表进去了又出来了，不在链上。
- $u$ 与 $v$ 在不同子树中，如 $u=5,v=3$。取出区间 $[ed_5,st_3]$，即 $(5,6,6,7,7,4,2,3)$，仍是出现一次的有贡献，但是没有计算到 $u,v$ 的 $lca$。处理完区间特判即可，统计完答案要删去。

实现细节中，我们要将出现两次的点忽略掉，可以使用 $vis$ 数组来记录。将 $vis_i$ 异或 $1$，如果 $vis_i=1$（第一次出现）则统计贡献，否则删除贡献。

在欧拉序上跑莫队即可处理所有询问区间。

**[标程](https://yumomeow.github.io/2025/02/24/std/#SP10707)**

## [34. LuoguP4074 - 糖果公园](https://www.luogu.com.cn/problem/P4074)
**莫队 树上莫队**
#### 题解
在树上莫队上添加修改即可，处理完欧拉序跑莫队，根据当前时间决定向前或向后修改。加入元素时，注意维护次数，根据次数选择不同的 $W_i$，如下：
```cpp
void update(int x){
    vis[x]^=1;
    if(vis[x]) sum+=w[++cnt[c[x]]]*v[c[x]];
    else sum-=w[cnt[c[x]]--]*v[c[x]];
}
```
**[标程](https://yumomeow.github.io/2025/02/24/std/#LuoguP4074)**

## [35. LuoguP3396 - 哈希冲突](https://www.luogu.com.cn/problem/P3396)
**根号分治**
#### 题意
给定一个序列，要求支持单点修改与查询序列中模 $p$ 等于 $x$ 的数的和。
#### 题解
我们可以根据 $p$ 的大小用不同的方式求解。

对于 $\le \sqrt n$ 的 $p$，我们对每一个 $p$ 都暴力预处理，询问时 $O(1)$ 回答，这样的复杂度是 $O(n \sqrt n)$。

对于 $> \sqrt n$ 的 $p$，因为对答案有贡献的值的数量一定 $\le \frac{n}{p}$ 也就是 $\sqrt n$，每次我们只需要暴力遍历序列即可，时间复杂度也是 $O(\sqrt n)$。

这种处理方式就是根号分治。

**[标程](https://yumomeow.github.io/2025/02/24/std/#LuoguP3396)**