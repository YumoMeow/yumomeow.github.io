---
title: 3.20 模拟赛总结
date: 2025-03-20 09:08:00
excerpt: wyq布置的模拟赛题。。
categories: 
    - 总结
tags: 
    - 数据结构
    - 线段树
    - 动态规划
    - 区间 DP
    - 数学
comment: 'utterances'
---
找了几个往年的 NOIP 真题来做。
## [A. LuoguP11362 - 遗失的赋值](https://www.luogu.com.cn/problem/P11362)
> 有 $n$ 个变量，值域均为 $[1,v]$。
> 
> 有 $n-1$ 条二元限制 $(a_i,b_i)$，表示若 $x_i=a_i$，则要求 $x_{i+1}=b_i$，否则对 $x_{i+1}$ 的值不作约束（$a_i,b_i\in [1,v]$）。有 $m$ 条一元限制 $(c_i,d_i)$ 要求 $x_{c_i}=d_i$。
>
> 给出所有的一元限制，求有多少种 $a_i,b_i$ 的组合可以同时满足所有限制。  
> $1\le n\le 10^9$，$1\le m\le 10^5$

我们考虑从 $m$ 入手。可以将整个数列拆成一些满足左右端点均有一元限制的极短的区间，对每个区间分别考虑。设左端点为 $i$，右端点为 $j$。

直接计算区间内合法方案数不太好算，**正难则反**，用所有方案数减去不合法的方案数。

所有方案数很显然为 $v^{2(j-i)}$，区间中的 $j-i$ 个限制每个都有 $v^2$ 种选择，乘起来即可。对于不合法的方案数，$a_i$ 只有一种选择，对于 $p\in [i,j-2]$，$b_p$ 有 $v$ 种选择，$a_{p+1}$ 只有一种选择，最后 $b_{j-1}$ 有 $v-1$ 种选择，合法方案数即为：
$$
v^{2(j-i)}-v^{j-i-1}(v-1)
$$

除此之外，还要考虑区间 $[1,c_1]$ 和 $[c_m,n]$。这部分 $a,b$ 可以任选，答案为 $v^{2(c_1-1+n-c_m)}$。

综上，最终答案为：
$$
v^{2(c_1-1+n-c_m)}\prod_{i=2}^m\big(v^{2(j-i)}-v^{j-i-1}(v-1)\big)
$$
快速幂就能算。

## [B. LuoguP9119 - 圣诞树](https://www.luogu.com.cn/problem/P9119)
> 二维平面上给定一个凸多边形，要求从 $y$ 坐标最高的点开始，每个点恰好走一遍，求最短距离。  
> $1\le n\le 1000$。

这道题只要想到 dp 就很简单了。设起点为 $k$，$f_{l,r,0/1}$ 表示当前已走完区间 $[l,r]$，现在在点 $l$ 还是点 $r$。因为是个闭合的多边形，我们将区间复制两遍。可以写出状态转移方程：
$$
f_{i,j,0}=\min\big(f_{i+1,j,0}+dis(i,i+1),f_{i+1,j,1}+dis(i,j)\big)\\
f_{i,j,1}=\min\big(f_{i,j-1,1}+dis(j-1,j),f_{i,j-1,0}+dis(i,j)\big)
$$

答案即为 $\min(f_{k,k+n-1,0},f_{k,k+n-1,1},f_{k+1,k+n,0},f_{k+1,k+n,1})$。

对于输出方案，记录每个 $f$ 值从哪里转移过来的即可。

## [D. LuoguP9871 - 天天爱打卡](https://www.luogu.com.cn/problem/P9871)
> 一共有 $n$ 天，可以花费 $d$ 的能量在任何一天跑步，但不能连续跑超过 $k$ 天。给出 $m$ 段区间 $[l_i,r_i]$，如果在区间内每一天都跑了步，可以获得 $v_i$ 的能量。初始能量为 $0$，求 $n$ 天后的最大能量。  
> $1\le k\le n\le 10^9$，$1\le m\le 10^5$。

最简单的方法就是枚举第 $i$ 天选或不选，再判断满足的区间，赛时写挂了。初始的 dp 方程不太好想，想到方程后优化就比较简单了。

考虑 dp。设 $f_i$ 表示只考虑前 $i$ 天的最大可能答案。初始 $f_i=f_{i-1}$。可以写出一个状态转移方程：
$$
f_i=\max_{j=i-k}^{i}\big(f_{j-2}+d\times (i-j+1)+\sum_{\{k|j\le l_k\le r_k\le i\}}v_k\big)
$$
选择区间 $[j,i]$ 跑步，第 $j-1$ 天不跑，减去消耗的能量，加上满足的区间。时间复杂度 $O(nmk)$。

考虑如何优化。将方程中的 $i$ 提出来得到
$$
f_i=\max_{j=i-k}^{i}\big(f_{j-2}+dj+\sum_{\{k|j\le l_k\le r_k\le i\}}v_k\big)-d(i+1)\\
$$
这样括号里的东西就可以全扔到线段树里维护了。将区间离散化，对每个以 $i$ 为右端点的区间，将区间 $[1,l_i]$ 都加上 $v_i$ 表示当 $j$ 在这个区间内时可以有 $v_i$ 的贡献。再将 $f_{j-2}+d(j-1)$ 加入线段树后，求区间最大值即可。代码中还有一些实现细节：
```cpp
for(int i=1,k=1;i<=tot;i++){
    f[i]=0;
    while(p[k].r==i&&k<=m) add(1,1,tot,1,p[k].l,p[k].w),++k;//加入区间
    int l=1,r=tot,j=tot;
    while(l<=r){
        if(X[mid]>=X[i]-K+1) j=mid,r=mid-1;
        else l=mid+1;
    }//二分出来最左端的 j 满足 j>=i-k
    int pos=max((X[i-1]!=X[i]-1?i-1:i-2),0ll);//pos 即为 j-2。如果上个端点离 i 只差 1 那 j-2 就在上上个端点处，否则就是上个端点。
    add(1,1,tot,i,i,f[pos]+X[i]*d);//将 i 加入线段树
    f[i]=max(f[i],query(1,1,tot,j,i))-(X[i]+1)*d; //区间最大值
    f[i]=max(f[i],f[i-1]);
}
```