---
title: 2.24 模拟赛总结
date: 2025-02-24 19:25:00
excerpt: wyq布置的模拟赛题。。
categories: 
    - 总结
tags: 
    - 数据结构
    - 树状数组
    - 线段树
    - 平衡树
    - 分块
    - ST表
---
数据结构题。。

## [A. LuoguP1637 - 三元上升子序列](https://www.luogu.com.cn/problem/P1637)
**树状数组**
#### 题意
给定一个数列，求满足 $i<j<k$ 且 $a_i<a_j<a_k$ 的 $i,j,k$ 个数。
#### 题解
对于这种求三个数之间关系的题，很容易想到对中间的数考虑。

枚举数列中的每一个数并将它作为 $j$，能够和它组成三元组的 $i$ 必须满足 $i<j$ 且 $a_i<a_j$，即数列中在它前面且比它小的数。因为值域为 $1e5$，所以可以用树状数组维护每个数出现的次数，每次将 $a_j$ 插入树状数组并查询 $<a_j$ 的前缀和即可。

同样的，和它组三元组的 $k$ 必须满足 $j<k$ 且 $a_j<a_k$，即在它后面且比它大的数。我们从后往前扫一遍，每次插入 $a_j$ 并求 $>a_j$ 的后缀和即可。因为 $i$ 和 $k$ 可以两两配对，所以位置 $j$ 的贡献就是两次查询的前缀和相乘。

**[标程](https://yumomeow.github.io/2025/02/24/std/#LuoguP1637)**

## [B. LuoguP7706 - 文文的摄影布置](https://www.luogu.com.cn/problem/P7706)
**线段树**
#### 题意
给定一个数列，每个数有两个属性$A_i$ 与 $B_i$，在其中选一个长度为 $3$ 的子序列，分别为 $i,j,k$。

规定 $\psi(i,k) = A_i + A_k - \min_{j=i+1}^{k-1}B_j$，其中 $i<j<k$。

支持单点修改 $A$ 数组或 $B$ 数组，和给定 $l,r$，求 $\psi(x,y)$ 的最大值 $(l\le x\le x+1<y\le r)$

#### 题解
对于区间操作想到用线段树维护，一般的想法是每个结点记录区间内 $\psi$ 的最大值，简记为 $\psi$。

由于只有单点修改所以不用 pushdown，考虑如何向上合并。

对于结点内的 $\psi$，有三种可能的来源：
- $\max(\psi_{ls},\psi_{rs})$。
- 左子树中选了最大的 $A_i$，右子树中选了最大的 $A_k-B_j$，合并为最大的 $\psi$。
- 右子树中选了最大的 $A_k$，左子树中选了最大的 $A_i-B_j$，合并为最大的 $\psi$。

维护出三者后取 $max$。

$maxA$ 可以直接维护，考虑如何维护 $A_k-B_j$ 与 $A_i-B_j$，分别记为 $P,Q$。

对于结点内的 $P$，可以由子树中的 $P$ 取最大值得到，或者左子树中取最小的 $B$，右子树中取最大的 $A$，保证差最大。将两者取 $max$。

对于结点内的 $Q$，有类似的方法，取子树 $Q$ 的最大值，或在右子树中取最小的 $B$，左子树中取最大的 $A$，保证差最大，两者取 $max$。

综上，线段树的一个结点所维护的信息有 $max\psi,maxA,minB,maxP,maxQ$，转移即可。

**[标程](https://yumomeow.github.io/2025/02/24/std/#LuoguP7706)**

## [C. LuoguP4146 - 序列终结者](https://www.luogu.com.cn/problem/P4146)
**平衡树**
#### 题意
给定一个序列，要求支持区间加，区间反转以及查询区间最大值。
#### 题解
区间反转的模板题是[LuoguP3391](https://www.luogu.com.cn/problem/P3391)。区间反转操作适合用平衡树维护，这里讲 Splay 树做法（Treap不会）。

与普通平衡树不同的是，它维护的不再是值之间的大小关系，而是下标之间的大小关系。每个结点对应一个下标，储存下标的值，左子树内结点的下标小于它，右子树内结点的下标大于它。

我们可以很容易地反转某个区间。首先考虑如何提取出这个区间。假设要提取出区间 $[l,r]$，根据二叉查找树的性质，如果以 $l-1$ 为根，它右子树中的点为 $[l,n]$。此时如果以 $r+1$ 为右子树的根，那么 $r+1$ 左子树中的点就同时满足大于 $l-1$ 与小于 $r+1$，即是区间 $[l,r]$。所以，先将 $l-1$ 旋到根，再将 $r+1$ 旋到 $l-1$ 下面，$r+1$ 的左子树就是区间 $[l,r]$，对它进行操作。

考虑反转这个区间。这里使用了 lazytag 思想，即先反转代表这个区间的结点的两个子树，再给子树打上懒标记。要访问区间内某个点或者这个区间要被破坏时，再下传标记。下传时将标记异或 $1$ 即可。
```cpp
void reverse(int l,int r){
	int x=find(l-1),y=find(r+1);//find为找到这个值在树上的结点编号，即找第 k 小值。
	splay(x,0);splay(y,x);
	tr[ls(y)].revtag^=1;
	swap(ls(ls(y)),rs(ls(y)));
	pushup(y);pushup(x);
}
```

加法操作类似，同样是先提取出这个区间，修改后打上 lazytag，访问时再下传。

注意区间最大值的维护，由于每个结点中都储存了一个值，所以更新这个结点代表区间的max时，要在左右子树max和结点自身的数值中取最大值，换句话说修改与pushdown时要多维护每个结点自身的值。修改与pushdown的写法类似，以pushdown为例。
```cpp
void pushdown(int x){
    //key即为结点自身的值
	if(tr[x].addtag){
		int k=tr[x].addtag;
		tr[ls(x)].ma+=k,tr[ls(x)].addtag+=k,tr[ls(x)].key+=k;
		tr[rs(x)].ma+=k,tr[rs(x)].addtag+=k,tr[rs(x)].key+=k;
		tr[x].addtag=0;
	}
	if(tr[x].revtag){
		swap(ls(ls(x)),rs(ls(x))),tr[ls(x)].revtag^=1;
		swap(ls(rs(x)),rs(rs(x))),tr[rs(x)].revtag^=1;
		tr[x].revtag=0;		
	}
}
```
查询时，由于我们每次修改完左右子树都进行了pushup操作，所以根节点维护的信息始终是对的，不需要向下递归寻找。
```cpp
int query(int l,int r){
	int x=find(l-1),y=find(r+1);
	splay(x,0);splay(y,x);
	return tr[ls(y)].ma;	
}
```
实现细节中有一点需要注意，因为我们要将 $l-1$ 旋转到根，为了避免当 $l=1$ 时这个点不存在，我们插入一个零号虚点，将它的最大值设为 $-INF$。同样我们也插入一个 $n+1$ 号的虚点。因为下标为零不方便，我们将所有的点向右偏移一格。

在修改与查询之前我们要先建出一个完整的树并处理好区间最值。
```cpp
int build(int l,int r,int f){
	if(l>r)return 0;
	int mid=(l+r)>>1;
	tr[mid].f=f;
	if(l==r){
		if(l==1||l==n+2) tr[l].ma=tr[l].key=-1e9;//虚点
		tr[l].siz=1;
		return l;
	}
	ls(mid)=build(l,mid-1,mid);
	rs(mid)=build(mid+1,r,mid);
	pushup(mid);
	return mid;
}
```
**[标程](https://yumomeow.github.io/2025/02/24/std/#LuoguP4146)**

## [D. LuoguP3793 - 由乃救爷爷](https://www.luogu.com.cn/problem/P3793)
**ST表 分块**
#### 题意
给定一个数列，每次询问区间最大值。数列长度与询问数量最大均为 $2e7$，数据完全随机。
#### 题解
通常求区间最大值方法为直接对整个序列建立 ST表，但对于这个问题，$O(n\log n)$ 的空间复杂度不被允许。我们要将空间复杂度压缩到 $O(n)$ 以下。

考虑到数列很长且区间随机，每次查询必定会覆盖很长的一段。我们可以分块处理，$O(n)$ 预处理出每一块内的最大值并对它建立 ST 表，这样空间复杂度就被压缩到了 $O(\sqrt n\log \sqrt n)$，快速查询整块内的最大值，对于前后的零散数据，分别处理出前缀和与后缀和，取 max。这样，跨越多个块的 $l,r$ 查询复杂度就可以做到 $O(1)$。但是对于同一块内的区间，无法做到 $O(1)$ 查询，只能暴力遍历，每次复杂度 $O(\sqrt n)$。但由于数据随机，属于同一块的区间必定很少，所以能过。

**[标程](https://yumomeow.github.io/2025/02/24/std/#LuoguP3793)**